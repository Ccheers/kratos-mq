// Code generated by github.com/Ccheers/kratos-mq/protoc-gen-mq. DO NOT EDIT.

package v1

import (
	context "context"
	mq "github.com/Ccheers/kratos-mq/mq"
	metadata "github.com/go-kratos/kratos/v2/metadata"
	middleware "github.com/go-kratos/kratos/v2/middleware"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the Ccheers/protoc-gen-mq package it is being compiled against.

//
type HelloMQServer interface {
	MQ_HelloWorld(context.Context, *HelloWorldRequest) error
}

func RegisterHelloMQServer(svr *mq.Server, srv HelloMQServer) error {
	var err error
	err = svr.Subscriber("tp1", "ch1", HelloWorld_0_MQHandler(svr, srv))
	if err != nil {
		return err
	}
	err = svr.Subscriber("tp2", "ch2", HelloWorld_1_MQHandler(svr, srv))
	if err != nil {
		return err
	}
	return nil
}
func HelloWorld_0_MQHandler(svr *mq.Server, srv HelloMQServer) mq.HandleFunc {
	return func(ctx context.Context, message mq.Message) {

		var in HelloWorldRequest
		var err error

		err = svr.DecodeFunc()(ctx, message, &in)
		if err != nil {
			svr.ErrHandler().Handle(err)
			return
		}

		md := metadata.New(nil)

		for k, v := range message.Metadata() {
			md.Set(k, v)
		}

		newCtx := metadata.NewServerContext(ctx, md)

		ms := mq.GetMiddlewareFromContext(ctx)

		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			err := srv.MQ_HelloWorld(ctx, req.(*HelloWorldRequest))
			return nil, err
		}

		_, err = middleware.Chain(ms...)(handler)(newCtx, &in)
		if err != nil {
			svr.ErrHandler().Handle(err)
			return
		}

	}
}
func HelloWorld_1_MQHandler(svr *mq.Server, srv HelloMQServer) mq.HandleFunc {
	return func(ctx context.Context, message mq.Message) {

		var in HelloWorldRequest
		var err error

		err = svr.DecodeFunc()(ctx, message, &in)
		if err != nil {
			svr.ErrHandler().Handle(err)
			return
		}

		md := metadata.New(nil)

		for k, v := range message.Metadata() {
			md.Set(k, v)
		}

		newCtx := metadata.NewServerContext(ctx, md)

		ms := mq.GetMiddlewareFromContext(ctx)

		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			err := srv.MQ_HelloWorld(ctx, req.(*HelloWorldRequest))
			return nil, err
		}

		_, err = middleware.Chain(ms...)(handler)(newCtx, &in)
		if err != nil {
			svr.ErrHandler().Handle(err)
			return
		}

	}
}

type HelloMQClient interface {
	HelloWorld_tp1(context.Context, *HelloWorldRequest) error
	HelloWorld_tp2(context.Context, *HelloWorldRequest) error
}
type HelloMQClientImpl struct {
	cc *mq.Client
}

func NewHelloMQClient(cc *mq.Client) HelloMQClient {
	return &HelloMQClientImpl{cc: cc}
}
func (x *HelloMQClientImpl) HelloWorld_tp1(ctx context.Context, req *HelloWorldRequest) error {
	return x.cc.Invoke(ctx, "tp1", req)
}
func (x *HelloMQClientImpl) HelloWorld_tp2(ctx context.Context, req *HelloWorldRequest) error {
	return x.cc.Invoke(ctx, "tp2", req)
}
